---
title: "desafio 10"
format: pdf
editor: visual
---

# **Introdução ao Polars**

```{python}
from datetime import datetime

print("Executado em:", datetime.now().strftime("%Y-%m-%d %H:%M:%S"))
```

-   Uma biblioteca Python de código aberto para manipulação e análise de dados.

-   Conhecida por seu alto desempenho, especialmente em tarefas que envolvem grandes volumes de dados.

-   Construída em Rust, o que contribui para sua velocidade e eficiência.

-   Oferece uma API intuitiva e expressiva, similar à do Pandas, facilitando a adoção por usuários familiarizados com essa biblioteca.

-   Velocidade: Polars é significativamente mais rápido que o Pandas em muitas operações, graças à sua arquitetura otimizada e ao uso de Rust.

-   Eficiência de Memória: Utiliza a memória de forma mais eficiente, permitindo trabalhar com conjuntos de dados maiores sem sobrecarregar o sistema.

-   Paralelismo: Aproveita o poder de processamento de múltiplos núcleos para executar tarefas em paralelo, acelerando ainda mais o processamento.

-   Flexibilidade: Suporta uma ampla gama de operações de manipulação de dados, como filtragem, agregação, ordenação e junção.

-   Integração: Funciona bem com outras bibliotecas populares do ecossistema Python, como NumPy e PyArrow.

-   Cenários com Grandes Conjuntos de Dados: Se você trabalha com datasets que não cabem confortavelmente na memória ou que exigem processamento rápido, Polars é uma excelente opção.

-   Tarefas de Análise Exploratória de Dados (EDA): A velocidade e eficiência do Polars permitem realizar análises exploratórias de forma mais ágil e interativa.

-   Aplicações de Ciência de Dados: A capacidade de lidar com grandes volumes de dados e realizar operações complexas torna o Polars adequado para projetos de aprendizado de máquina e outras áreas da ciência de dados.

## Instalação Polars

-   O modo mais simples de instalar o Polars é utilizando o terminal do seu computador.

-   A instalação pressupõem que o Python já esteja instalado.

```{r}
reticulate::py_install("polars")
reticulate::py_install("pyarrow")
```

## **Carregando a biblioteca Polars**

-   Para utilizar as funções disponibilizadas pela biblioteca, você deve importá-la no início da sua sessão.

-   No Python, com o intuito de proteger-se contra conflitos com os nomes de funções disponibilizadas por diferentes bibliotecas, utilizamos frequentemente o conceito de *namespace*.

-   Assim, ao importarmos uma biblioteca, recomenda-se atribuir um nome curto (*alias*) à mesma.

-   Sempre que formos empregar uma função daquela biblioteca, utilizamos a notação `alias.funcao()`.

```{python}
import polars as pl
```

```{python}
#!pip install polars
#!pip install fastexcel
```

```{python}
import polars as pl
```

# **Arquivos Tabulares**

## **Leitura de Arquivos Tabulares**

-   Ao importar arquivos tabulares, o Polars os representa como um objeto de classe `DataFrame` no Python.

-   Os tipos de arquivo abaixo podem ser importados da seguinte maneira:

    -   Arquivos delimitados (como CSV e TSV): `pl.read_csv()`.

    -   Arquivos Parquet: `pl.read_parquet()`.

    -   Arquivos JSON: `pl.read_json()`.

    -   Arquivos Excel: `pl.read_excel()`.

        -   Necessita da biblioteca `fastexcel`!

## **Argumentos Importantes**

-   `file`: Caminho para o arquivo ou objeto file-like (para URLs).

    -   `pl.read_csv("dados.csv")`

-   `columns`: Lista de colunas a serem lidas.

    -   `pl.read_csv("dados.csv", columns=["coluna1", "coluna3"])`

-   `dtypes`: Dicionário especificando os tipos de dados das colunas.

    -   `pl.read_csv("dados.csv", dtypes={"idade": pl.Int32})`

-   `infer_schema_length`: Número de linhas para inferir o esquema.

    -   `pl.read_csv("dados.grande.csv", infer_schema_length=1000)`

-   `has_header`: Indica se o arquivo possui cabeçalho.

    -   `pl.read_csv("dados_sem_header.csv", has_header=False)`

-   `delimiter`: Delimitador usado no arquivo (padrão é ‘,’).

    -   `pl.read_csv("dados.tsv", delimiter="\t")`

## **Exemplo `airports.csv`**

```{r}
getwd()
```

```{python}
aeroportos = pl.read_csv("H:/Documentos/me315/airports.csv",
                         columns = ["IATA_CODE", "CITY", "STATE"])
aeroportos.head(2)
```

## **Exemplo `WDIEXCEL.xlsx`**

```{python}
wdi = pl.read_excel("H:/Documentos/me315/WDIEXCEL.xlsx", 
sheet_name = "Country", 
columns = ["Short Name", "Region"])
wdi.head(2)
```

# **Operações em DataFrames**

## **Um Exemplo Simples**

```{python}
df = pl.DataFrame({
    "grupo": ["A", "A", "B", "B", "C"],
    "valor1": [10, 15, 10, None, 25],
    "valor2": [5, None, 20, 30, None]
})
df
```

## **Operando em `valor1`?**

```{python}
df["valor1"]
```

```{python}
df["valor1"].mean()
```

```{python}
df["valor1"].drop_nulls()
```

```{python}
df["valor1"].drop_nulls().mean()
```

## **Operando em Colunas**

```{python}
df.select([
  pl.col("valor1").mean().alias("media_v1"),
  pl.col("valor2").mean()
])
```

## **Exemplo**

Quais são as médias da variável `valor1` e o valor mínimo da variável `valor2` para cada um dos grupos definidos por `grupo`?

```{python}
df.group_by("grupo").agg([
  pl.col("valor1").mean().alias("media_valor1"),
  pl.col("valor2").min().alias("min_valor2")
]).sort("grupo")
```

## **De volta ao `flights.csv`**

Calcule o percentual de vôos das cias. aéreas “AA” e “DL” que atrasaram pelo menos 30 minutos nas chegadas aos aeroportos “SEA”, “MIA” e “BWI”.

```{python}
voos = pl.read_csv("H:/Documentos/me315/flights.csv",
                   columns = ["AIRLINE", "ARRIVAL_DELAY", "DESTINATION_AIRPORT"],
                   dtypes = {"AIRLINE": pl.Utf8,
                             "ARRIVAL_DELAY": pl.Int32,
                             "DESTINATION_AIRPORT": pl.Utf8})
voos.shape
```

```{python}
voos.head(3)
```

Calcule o percentual de vôos das cias. aéreas “AA” e “DL” que atrasaram pelo menos 30 minutos nas chegadas aos aeroportos “SEA”, “MIA” e “BWI”.

```{python}
resultado = (
  voos.drop_nulls(["AIRLINE", "DESTINATION_AIRPORT", "ARRIVAL_DELAY"])
  .filter(
    pl.col("AIRLINE").is_in(["AA", "DL"]) &
    pl.col("DESTINATION_AIRPORT").is_in(["SEA", "MIA", "BWI"])
    )
    .group_by(["AIRLINE", "DESTINATION_AIRPORT"])
    .agg([
      (pl.col("ARRIVAL_DELAY") > 30).mean().alias("atraso_medio")
      ])
)
```

```{python}
resultado.sort("atraso_medio")
```

# **Dados Relacionais com Polars**

## **Estruturas Relacionais com Duas Tabelas**

-   Em bancos de dados relacionais, informações frequentemente estão organizadas em múltiplas tabelas que se relacionam entre si através de chaves.

-   A chave é uma coluna (ou conjunto de colunas) que permite identificar e associar os dados de uma tabela com os de outra.

```{python}
import polars as pl

# Criando DataFrames
clientes = pl.DataFrame({
    "cliente_id": [1, 2, 3, 4],
    "nome": ["Ana", "Bruno", "Clara", "Daniel"]
})

print(clientes)
```

## **Dados Compras**

```{python}
pedidos = pl.DataFrame({
    "pedido_id": [101, 102, 103, 104, 105],
    "cliente_id": [1, 2, 3, 1, 5],
    "valor": [100.50, 250.75, 75.00, 130.00, 79.00]
})

print(pedidos)
```

## **JOINs**

-   Um `JOIN` combina registros de duas tabelas com base em uma coluna comum (chave).

-   É amplamente utilizado em manipulação de dados relacionais.

-   Deve ser empregado para combinar informações de duas (ou mais) tabelas que compartilham chaves entre si.

## **`INNER JOIN`**

Retorna apenas as linhas que têm correspondências (de chaves) nas duas tabelas.

## **Exemplo `INNER JOIN`**

```{python}
res_ij = clientes.join(pedidos, on="cliente_id", how="inner")
print(res_ij)
```

## **`LEFT/RIGHT JOIN`**

Retorna todas as linhas da tabela à esquerda \[direita\] e as correspondentes da direita \[esquerda\] (se houver).

## **Exemplo `LEFT JOIN`**

```{python}
res_lj = clientes.join(pedidos, on="cliente_id", how="left")
print(res_lj)
```

## **Exemplo `RIGHT JOIN`**

```{python}
res_rj = clientes.join(pedidos, on="cliente_id", how="right")
print(res_rj)
```

## **`OUTER JOIN`**

Retorna todas as linhas quando há uma correspondência em uma das tabelas.

## **Exemplo `OUTER JOIN`**

```{python}
res_oj = clientes.join(pedidos, on="cliente_id", how="outer")
print(res_oj)
```

## **`CROSS JOIN`**

Retorna o produto cartesiano de ambas as tabelas.

## **Exemplo `CROSS JOIN`**

```{python}
res_cj = clientes.join(pedidos, how="cross")
print(res_cj)
```

## **Operações em Tabelas Combinadas**

-   Ao final de uma operação do tipo `JOIN`, a tabela resultante continua sendo um `DataFrame`.

-   Todas as operações para `DataFrame` podem ser aplicadas:

    -   Filtros

    -   Seleções

    -   Operações Agregadas

# **P1: Qual é o valor médio das compras realizadas para cada cliente identificado?**

```{python}
print(clientes)
```

```{python}
print(pedidos)
```

```{python}
res = res_ij.group_by(["nome", "cliente_id"]).agg(pl.col("valor").mean())
print(res)
```

# **P2: Informe os nomes e a quantidade de compras com valor mínimo de \$100.00 realizadas por cada cliente.**

```{python}
print(clientes)
```

```{python}
print(pedidos)
```

```{python}
res = (res_oj.with_columns(pl.col("valor") > 100)
       .group_by("nome")
       .agg(pl.col("valor").sum()))
print(res)
```

## **`JOIN` com Múltiplas Colunas como Chave**

```{python}
vendas = pl.DataFrame({
    "id_venda": [1, 2, 3],
    "id_cl": [1, 2, 1],
    "id_prod": [101, 102, 103],
    "qtde": [2, 1, 1]
})

detalhes_pedidos = pl.DataFrame({
    "id_ped": [201, 202, 203],
    "cl_id": [1, 2, 1],
    "id_prod": [101, 102, 104],
    "valor": [50.00, 75.00, 100.00]
})
```

```{python}
print(vendas)
```

```{python}
print(detalhes_pedidos)
```

## **Realizando um `JOIN` com Múltiplas Colunas**

```{python}
final = vendas.join(detalhes_pedidos,
                    left_on = ["id_cl", "id_prod"],
                    right_on = ["cl_id", "id_prod"],
                    how = "inner")
print(final)
```
